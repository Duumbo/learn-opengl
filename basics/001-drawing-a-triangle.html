<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Drawing A Triangle - Learn OpenGL Rust</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="A version of the LearnOpenGL book for Rust.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="../basics/index.html"><strong aria-hidden="true">1.</strong> Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../basics/000-creating-a-window.html"><strong aria-hidden="true">1.1.</strong> Creating A Window</a></li><li class="chapter-item expanded "><a href="../basics/001-drawing-a-triangle.html" class="active"><strong aria-hidden="true">1.2.</strong> Drawing A Triangle</a></li><li class="chapter-item expanded "><a href="../basics/002-triangle-cleanup.html"><strong aria-hidden="true">1.3.</strong> Triangle Cleanup</a></li><li class="chapter-item expanded "><a href="../basics/003-rectangle.html"><strong aria-hidden="true">1.4.</strong> Rectangle Elements</a></li></ol></li><li class="chapter-item expanded "><a href="../appendix-math/index.html"><strong aria-hidden="true">2.</strong> Appendix: Math</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../appendix-math/vectors.html"><strong aria-hidden="true">2.1.</strong> Vectors</a></li><li class="chapter-item expanded "><a href="../appendix-math/matrices.html"><strong aria-hidden="true">2.2.</strong> Matrices</a></li><li class="chapter-item expanded "><a href="../appendix-math/transform.html"><strong aria-hidden="true">2.3.</strong> Transforms</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Learn OpenGL Rust</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="drawing-a-triangle"><a class="header" href="#drawing-a-triangle">Drawing A Triangle</a></h1>
<p>In this lesson, we'll do a lot of setup just to be able to draw a single
triangle.</p>
<p>Don't worry, once you do the first batch of setup, drawing that <em>second</em>
triangle is easy.</p>
<h2 id="load-the-opengl-functions"><a class="header" href="#load-the-opengl-functions">Load The Opengl Functions</a></h2>
<p>Unlike most libraries that you can use in a program, OpenGL cannot be statically
linked to. Well, you can static link to very old versions, but any sort of newer
OpenGL library is installed on the user's system as a dynamic library that you
load at runtime. This way the user can get their video driver updates and then your program just loads in the new driver file the next time it turns on.</p>
<p>The details aren't too important to the rest of what we want to do, so I won't
discuss it here. Perhaps an appendix page or something at some point in the
future. The <code>ogl33</code> crate handles it for us. As a reminder, you could also use
the <code>gl</code> or <code>glow</code> crates.</p>
<p>After we open the window, we just say that we want to load up every OpenGL
function.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe {
  load_gl_with(|f_name| win.get_proc_address(f_name));
}
<span class="boring">}</span></code></pre></pre>
<h2 id="set-the-clear-screen-color"><a class="header" href="#set-the-clear-screen-color">Set The &quot;Clear&quot; Screen Color</a></h2>
<p>When we clear the previous image's data at the start of our drawing, by default it would clear to black. Since we'll only have one thing at a time to draw for a little bit, let's use a slightly softer sort of color.</p>
<p>We just need to call
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearColor.xhtml"><code>glClearColor</code></a>
with the red, green, blue, and alpha intensities that we want to use.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe {
  glClearColor(0.2, 0.3, 0.3, 1.0);
}
<span class="boring">}</span></code></pre></pre>
<p>This is a blue-green sort of color that's only a little bit away from being
gray. You can <em>kinda</em> tell that even before we open the window. The channel
values are all close (which is gray), but there's a little less red, so it tilts
towards being a blue-green.</p>
<p>The alpha value isn't important for now because our window itself isn't
transparent (so you can't see pixels behind it) and we're not doing any color
blending yet (so the alpha of the clear color compared to some other color
doesn't come into play). Eventually it might matter, so we'll just leave it on
&quot;fully opaque&quot; for now.</p>
<h2 id="send-a-triangle"><a class="header" href="#send-a-triangle">Send A Triangle</a></h2>
<p>At this point there's two main actions we need to take before we're ready for our triangle to be drawn.</p>
<ul>
<li>We need to get some triangle data to the video card in a way it understands.</li>
<li>We need to get a program to the video card so that it can make use of the data.</li>
</ul>
<p>Neither task depends on the other, so we'll send our triangle data first and
then send our program.</p>
<h3 id="generate-a-vertex-array-object"><a class="header" href="#generate-a-vertex-array-object">Generate A Vertex Array Object</a></h3>
<p>A <a href="https://www.khronos.org/opengl/wiki/Vertex_Specification#Vertex_Array_Object">Vertex Array
Object</a>
(VAO) is an object that collects together a few different bits of stuff.
Basically, at any given moment there either is a Vertex Array Object &quot;bound&quot;,
meaning it's the active one, or there is not one bound, which makes basically
all commands that relate to buffering data and describing data invalid. Since we
want to buffer some data and describe it, we need to have a VAO bound.</p>
<p>You make a vertex array object with
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenVertexArrays.xhtml"><code>glGenVertexArrays</code></a>.
It takes the length of an array to fill, and a pointer to the start of that
array. Then it fills the array with the names of a bunch of new VAOs. You're
allowed to make a lot of vertex arrays at once if you want, but we just need one
for now. Luckily, a pointer to just one thing is the same as a pointer to an
array of length 1.</p>
<p>Also, <code>glGenVertexArrays</code> <em>shouldn't</em> ever return 0, but if some sort of bug
happened it could, so we'll throw in a little assert just to check that.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe {
  let mut vao = 0;
  glGenVertexArrays(1, &amp;mut vao);
  assert_ne!(vao, 0);
}
<span class="boring">}</span></code></pre></pre>
<p>Once we have a VAO we can &quot;bind&quot; it with
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindVertexArray.xhtml"><code>glBindVertexArray</code></a>
to make it the active VAO. This is a <em>context wide</em> effect, so now all GL
functions in our GL context will do whatever they do with this VAO as the VAO to
work with.</p>
<p>As a note: you can also bind the value 0 at any time, which clears the vertex
array binding. This might sound a little silly, but it can help spot bugs in
some situations. If you have no VAO bound when you try to call VAO affected
functions it'll generate an error, which usually means that you forgot to bind
the VAO that you really did want to affect.</p>
<h3 id="generate-a-vertex-buffer-object"><a class="header" href="#generate-a-vertex-buffer-object">Generate A Vertex Buffer Object</a></h3>
<p>To actually get some bytes of data to the video card we need a <a href="https://www.khronos.org/opengl/wiki/Vertex_Specification#Vertex_Buffer_Object">Vertex Buffer
Object</a>
(VBO) to go with our Vertex Array Object. You might get sick of the words
&quot;vertex&quot; and &quot;object&quot; by the time you've read this whole book.</p>
<p>This time things are a little different than with the VAO. Instead of calling a
function to make and bind specifically a <em>vertex</em> buffer object, there's just a
common function to make and bind buffers of all sorts. It's called
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenBuffers.xhtml"><code>glGenBuffers</code></a>,
and it works mostly the same as <code>glGenVertexArrays</code> did, you pass a length and a
pointer and it fills an array.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe {
  let mut vbo = 0;
  glGenBuffers(1, &amp;mut vbo);
  assert_ne!(vbo, 0);
}
<span class="boring">}</span></code></pre></pre>
<p>Now that we have a buffer, we can bind it to the binding target that we want.
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindBuffer.xhtml"><code>glBindBuffer</code></a>
takes a target name and a buffer. As you can see on that page, there's a whole
lot of options, but for now we just want to use the <code>GL_ARRAY_BUFFER</code> target.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe {
  glBindBuffer(GL_ARRAY_BUFFER, vbo);
}
<span class="boring">}</span></code></pre></pre>
<p>And, similar to the VAO's binding process, now that our vertex buffer object is
bound to the the <code>GL_ARRAY_BUFFER</code> target, all commands using that target will
operate on the buffer that we just made.</p>
<p>(Is this whole binding thing a dumb way to design an API? Yeah, it is. Oh well.)</p>
<p>Now that we have a buffer bound as the <code>GL_ARRAY_BUFFER</code>, we can finally use <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferData.xhtml"><code>glBufferData</code></a> to actually send over some data bytes. We have to specify the binding target we want to buffer to, the <code>isize</code> of the number of bytes we want to buffer, the const pointer to the start of the data we're buffering, and the usage hint.</p>
<p>Most of that is self explanatory, except the usage hint. Basically there's
memory that's faster or slower for the GPU to use or the CPU to use. If we hint
to the GPU how we intend to use the data and how often we intend to update it
then it has a chance to make a smarter choice of where to put the data. You can
see all the options on the <code>glBufferData</code> spec page. For our first demo we want
<code>GL_STATIC_DRAW</code>, since we'll just be sending the data once, and then GL will
draw with it many times.</p>
<p>But what data do we send?</p>
<h4 id="demo-vertex-data"><a class="header" href="#demo-vertex-data">Demo Vertex Data</a></h4>
<p>We're going to be sending this data:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Vertex = [f32; 3];
const VERTICES: [Vertex; 3] =
  [[-0.5, -0.5, 0.0], [0.5, -0.5, 0.0], [0.0, 0.5, 0.0]];
<span class="boring">}</span></code></pre></pre>
<p>It describes a triangle in Normalized Device Context (NDC) coordinates. Each
vertex is an [X, Y, Z] triple, and we have three vertices.</p>
<p>We can also use
<a href="https://doc.rust-lang.org/core/mem/fn.size_of_val.html"><code>size_of_val</code></a> to get
the byte count, and
<a href="https://doc.rust-lang.org/std/primitive.slice.html#method.as_ptr"><code>as_ptr</code></a>
followed by
<a href="https://doc.rust-lang.org/std/primitive.pointer.html#method.cast"><code>cast</code></a> to
get a pointer of the right type. In this case, GL wants a &quot;void pointer&quot;, which
isn't a type that exists in Rust, but it's what C calls a &quot;pointer to anything&quot;.
Since the buffer function need to be able to accept anything you want to buffer,
it takes a void pointer.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe {
  glBufferData(
    GL_ARRAY_BUFFER,
    size_of_val(&amp;VERTICES) as isize,
    VERTICES.as_ptr().cast(),
    GL_STATIC_DRAW,
  );
}
<span class="boring">}</span></code></pre></pre>
<p>Good to go!</p>
<h3 id="enable-a-vertex-attribute"><a class="header" href="#enable-a-vertex-attribute">Enable A Vertex Attribute</a></h3>
<p>How will the GPU know the correct way to use the bytes we just sent it? Good
question. We describe the &quot;vertex attributes&quot; and then it'll be able to
interpret the bytes correctly.</p>
<p>For each vertex attribute we want to describe we call <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribPointer.xhtml"><code>glVertexAttribPointer</code></a>. There's just one attribute for now (the position of the vertex), so we'll make just one call.</p>
<ul>
<li>The <code>index</code> is the attribute we're describing. Your selection here has to
match with the shader program that we make later on. We'll just use 0.</li>
<li>The <code>size</code> is the number of components in the attribute. Since each position
is a 3D XYZ position, we put 3.</li>
<li>The <code>type</code> is the type of data for the attribute. Since we're using <code>f32</code> we
pass <code>GL_FLOAT</code>.</li>
<li>The <code>normalized</code> setting has to do with fixed-point data values. That's not
related to us right now, so we just leave it as <code>GL_FALSE</code>.</li>
<li>The <code>stride</code> is the number of bytes from the start of this attribute in one
vertex to the start of the same attribute in the next vertex. Since we have
only one attribute right now, that's just <code>size_of::&lt;f32&gt;() * 3</code>. Alternately,
we can use <code>size_of::&lt;Vertex&gt;()</code> and when we edit our type alias at the top
later on this vertex attribute value will automatically be updated for us.</li>
<li>The <code>pointer</code> value is, a little confusingly, not a pointer to anywhere in
<em>our</em> memory space. Instead, it's a pointer to the start of this vertex
attribute within the buffer <em>as if</em> the buffer itself were starting at memory
location 0. Little strange, but whatever. Since this attribute is at the start
of the vertex, we use 0. When we have more attributes later all the attributes
will usually end up with the same <code>stride</code> but different <code>pointer</code> values. I'll be sure to review this point again later, because it's a little weird.</li>
</ul>
<p>Once we've described the vertex attribute pointer, we also need to enable it
with
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glEnableVertexAttribArray.xhtml"><code>glEnableVertexAttribArray</code></a>.
It just takes the name of the <code>index</code> to enable, so we pass 0.</p>
<p>Also, when we provide the stride it wants <code>isize</code> and Rust always uses <code>usize</code>
for sizes, so we have to convert there. In this case we'll use the
<a href="https://doc.rust-lang.org/core/convert/trait.TryInto.html"><code>TryInto::try_into</code></a>
trait method, along with an <code>unwrap</code>. It should work, but if somehow it would
have overflowed, it's better to explode in a controlled manner <em>now</em> than cause
the GPU to read memory way out of bounds at some unknown point <em>later</em>.</p>
<p>Also also, we have to convert the pointer location using <code>usize</code> values <em>and
then</em> cast to a const pointer once we have our <code>usize</code>. We <strong>do not</strong> want to
make a null pointer and then offset it with the <code>offset</code> method. That's gonna
generate an out of bounds pointer, which is UB. We could try to remember to use
the <code>wrapping_offset</code> method, or we could just do all the math in <code>usize</code> and
then cast at the end. I sure know which one I prefer.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe {
  glVertexAttribPointer(
    0,
    3,
    GL_FLOAT,
    GL_FALSE,
    size_of::&lt;Vertex&gt;().try_into().unwrap(),
    0 as *const _,
  );
  glEnableVertexAttribArray(0);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="send-a-program"><a class="header" href="#send-a-program">Send A Program</a></h2>
<p>Okay, we have some bytes sent to the GPU, and the GPU knows that it's a series
of vertexes which are each three <code>f32</code> values. How does it know what to do from
there? Again, with these good questions.</p>
<p>When your GPU draws a picture, that's called the &quot;graphics pipeline&quot;. Some parts
of the pipeline are totally fixed, or you can pick from one of a few options.
The rest is done by a &quot;shader program&quot;.</p>
<p>We need to make a <a href="https://www.khronos.org/opengl/wiki/GLSL_Object#Program_objects">Program
Object</a>,
compile and attach some shader stages to it, link the stages together, and then
use that program.</p>
<p>Of course, to attach those compiled shader stages we need to make some <a href="https://www.khronos.org/opengl/wiki/GLSL_Object#Shader_objects">Shader
Objects</a> too.
It's objects all the way down!</p>
<h3 id="create-a-vertex-shader"><a class="header" href="#create-a-vertex-shader">Create A Vertex Shader</a></h3>
<p>First we want a <a href="https://www.khronos.org/opengl/wiki/Vertex_Shader">Vertex Shader</a>.</p>
<p>This time we're <em>not</em> calling a &quot;gen&quot; style method with an array to fill and
getting a huge array of new shaders. GL assumes that you'll use sufficiently few
shaders that you can make them one at a time, so we call
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateShader.xhtml"><code>glCreateShader</code></a> with a shader type and we get just one shader back. Or 0 if there was an error.</p>
<p>If you look at the spec page there (and you should naturally have at least a
quick look at <em>all</em> of the spec pages I'm linking for you!), then you'll see
that there's a lot of types of shader! We only actually need <em>two</em> of them to
get our program going. Actually most GL programs will just use the Vertex and
Fragment shader. Even like complete products that aren't just demos. Vertex and
Fragment are essential, the others are optional and specialized.</p>
<p>One vertex shader please.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe {
  let vertex_shader = glCreateShader(GL_VERTEX_SHADER);
  assert_ne!(vertex_shader, 0);
}
<span class="boring">}</span></code></pre></pre>
<p>Thank you.</p>
<p>Now we need to upload some source code for this shader. The source code needs to
be written in a language called
<a href="https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)">GLSL</a>. Let's go with
a vertex shader that's about as simple as you can possibly get with a vertex
shader:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const VERT_SHADER: &amp;str = r#&quot;#version 330 core
  layout (location = 0) in vec3 pos;
  void main() {
    gl_Position = vec4(pos.x, pos.y, pos.z, 1.0);
  }
&quot;#;
<span class="boring">}</span></code></pre></pre>
<p>That's one long string literal with a lot of stuff inside it.</p>
<h4 id="inspecting-the-vertex-source"><a class="header" href="#inspecting-the-vertex-source">Inspecting The Vertex Source</a></h4>
<p>The first line of the vertex shader is a <code>#version 330 core</code>. You have to have
this line on the very first line, it identifies the version of the GLSL language
that your program is written for. In the same way that each version of OpenGL
adds a little more stuff you can do, each version of GLSL has a little more you
can do too. Version 330 is the version that goes with OpenGL 3.3, and we're using the core profile.</p>
<p>Now we get to the actual interesting bits. The job of the vertex shader is to
read in the vertex attribute values from the buffer, do whatever, and then write
to <code>gl_Position</code> with the position that this vertex should end up at.</p>
<pre><code class="language-glsl">layout (location = 0) in vec3 pos;
</code></pre>
<p>This specifies that at attribute index 0 within the buffer (remember how we set
vertex attribute 0 before?) there's an <code>in</code> variable, of type <code>vec3</code>, which
we're going to call <code>pos</code>.</p>
<pre><code class="language-glsl">void main() {
  gl_Position = vec4(pos.x, pos.y, pos.z, 1.0);
}
</code></pre>
<p>Like with Rust and C, GLSL programs start at <code>main</code>. Our main function reads the
<code>x</code>, <code>y</code>, and <code>z</code> of the vertex position, and then sticks a <code>1.0</code> on the end,
and writes that <code>vec4</code> into the <code>gl_Position</code> variable. It just copies over the
data, no math or anything. Not the most exciting. We'll have plenty of math
later, don't worry.</p>
<h4 id="upload-the-vertex-shader-source-and-compile"><a class="header" href="#upload-the-vertex-shader-source-and-compile">Upload The Vertex Shader Source, and Compile</a></h4>
<p>Now that we've got some source, we need to send it over. For this we use
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glShaderSource.xhtml"><code>glShaderSource</code></a>,
which is a little tricky to get right the first time. The first argument is the
name of a shader to set the source for. Next we have to describe the string data
sorta like with <code>glBufferData</code>, but the format is a little wonky. They're
expecting a length of two different arrays, and the first array is full of
string data, while the second array is full of the lengths of each string. This is supposed to allow you to... I dunno. It's some sort of C nonsense.</p>
<p>What we do in Rust is this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe {
  glShaderSource(
    vertex_shader,
    1,
    &amp;(VERT_SHADER.as_bytes().as_ptr().cast()),
    &amp;(VERT_SHADER.len().try_into().unwrap()),
  );
}
<span class="boring">}</span></code></pre></pre>
<p>Ah, look a little weird? Yeah it's still a little weird. So what's happening is that first we're saying that out array of strings and our array of string lengths will both have length 1. Like with <code>glGenBuffer</code>.</p>
<p>Then we're passing a pointer <em>to the pointer</em> of the start of the string. So we write <code>&amp;(expr)</code>, with a <code>&amp;</code> forced to the outside of our expression by the parentheses. If you don't have those parentheses then the order of operations goes wrong: it takes a reference to <code>VERTEX_SHADER</code>, calls <code>as_bytes</code> on that, and then you get a very wrong value at the end.</p>
<p>Then, for the length we do basically the same thing. We take a pointer <em>to the length</em> after getting the string length as an <code>i32</code> value.</p>
<p>Once that string data is uploaded we call <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompileShader.xhtml"><code>glCompileShader</code></a> to tell GL to compile it, and we're home free.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe {
  glCompileShader(vertex_shader);
}
<span class="boring">}</span></code></pre></pre>
<h4 id="check-for-an-error"><a class="header" href="#check-for-an-error">Check For An Error</a></h4>
<p>I lied just now, we're not home free.</p>
<p>Obviously, the one thing I'm very sure that you know about programming, is that sometimes when you compile a program there's an error. Maybe you spelled a word wrong, maybe a type didn't match, whatever. Anything could go wrong, so we have to check for that.</p>
<p>The checking process is actually more annoying than the compilation!</p>
<p>First we use
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetShader.xhtml"><code>glGetShaderiv</code></a>.
The <code>iv</code> part means &quot;int&quot; &quot;vector&quot;, so the output value will be that they'll
write to a pointer we send them. We have to pass the name of the shader we want
info on, the <code>GL_COMPILE_STATUS</code> specifier to get the compile status, and a
pointer that they can write to so we can get a value back. Side note:
out-parameter pointers are terrible, please never design your API this way.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe {
  let mut success = 0;
  glGetShaderiv(vertex_shader, GL_COMPILE_STATUS, &amp;mut success);
}
<span class="boring">}</span></code></pre></pre>
<p>So this <code>success</code> value is bool-style 1 for yes and 0 for no. You can also use
<code>GL_TRUE</code> and <code>GL_FALSE</code> but the types won't match up and in C you don't get
automatic conversion, so we'll just check for 0 (no success).</p>
<p>If there was not a success, then then <em>real</em> fun begins. That means we have to get a message out of the shader log.</p>
<p>We <em>could</em> check the info log length with <code>GL_INFO_LOG_LENGTH</code>, then allocate a
perfectly sized buffer and have them write to the buffer. However, that gives us
a <code>Vec&lt;u8&gt;</code> (or <code>Vec&lt;c_char&gt;</code> if you want), and then we convert that to
<code>String</code>. I like to use <code>String::from_utf8_lossy</code> when I've got unknown bytes,
which allocates its own buffer anyway, so we'll just allocate 1k of <code>Vec</code> and assume that the log length is 1024 or less.</p>
<p>So we call
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetShaderInfoLog.xhtml"><code>glGetShaderInfoLog</code></a>,
with the shader we want the info log for, the maximum capacity of our buffer, a
pointer to the spot where it will store the number of bytes written, and the
pointer to the buffer of course. Then we set the length of the <code>Vec</code>, convert to
<code>String</code>, and <code>panic!</code> (at the disco) with that error message.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe {
  if success == 0 {
    let mut v: Vec&lt;u8&gt; = Vec::with_capacity(1024);
    let mut log_len = 0_i32;
    glGetShaderInfoLog(
      vertex_shader,
      1024,
      &amp;mut log_len,
      v.as_mut_ptr().cast(),
    );
    v.set_len(log_len.try_into().unwrap());
    panic!(&quot;Vertex Compile Error: {}&quot;, String::from_utf8_lossy(&amp;v));
  }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="create-a-fragment-shader"><a class="header" href="#create-a-fragment-shader">Create A Fragment Shader</a></h3>
<p>Making a <a href="https://www.khronos.org/opengl/wiki/Fragment_Shader">Fragment Shader</a>
is nearly identical to making a vertex shader, except we pass a different shader
type. Also, we have some different source code of course.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe {
  let fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);
  assert_ne!(fragment_shader, 0);
}
<span class="boring">}</span></code></pre></pre>
<p>And the fragment source looks like this</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const FRAG_SHADER: &amp;str = r#&quot;#version 330 core
  out vec4 final_color;

  void main() {
    final_color = vec4(1.0, 0.5, 0.2, 1.0);
  }
&quot;#;
<span class="boring">}</span></code></pre></pre>
<h4 id="inspecting-the-fragment-source"><a class="header" href="#inspecting-the-fragment-source">Inspecting The Fragment Source</a></h4>
<p>Again we have a version line, always nice to have versions.</p>
<pre><code class="language-glsl">out vec4 final_color;
</code></pre>
<p>This says that we're going to output a <code>vec4</code>, and we'll call it <code>final_color</code>.
With the <code>gl_Position</code> value in the vertex shader, it's just assumed to be there
since every vertex shader needs to write a position out. With fragment shaders,
the system will just assume that whatever <code>vec4</code> your fragment shader puts out,
with any name, is the output color.</p>
<pre><code class="language-glsl">void main() {
  final_color = vec4(1.0, 0.5, 0.2, 1.0);
}
</code></pre>
<p>Here, the color is a kind of orange color, and it's the same everywhere.
Anywhere we have a fragment, we'll have an orange pixel.</p>
<p>I assure you that both vertex and fragment shaders will become more complex as
we go, but if you just want to draw <em>anything</em> it's this simple.</p>
<h4 id="upload-the-fragment-shader-source"><a class="header" href="#upload-the-fragment-shader-source">Upload The Fragment Shader Source</a></h4>
<p>And we upload and compile like before:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe {
  glShaderSource(
    fragment_shader,
    1,
    &amp;(FRAG_SHADER.as_bytes().as_ptr().cast()),
    &amp;(FRAG_SHADER.len().try_into().unwrap()),
  );
  glCompileShader(fragment_shader);
}
<span class="boring">}</span></code></pre></pre>
<h4 id="check-for-an-error-again"><a class="header" href="#check-for-an-error-again">Check For An Error, Again</a></h4>
<p>And we check for an error like before:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe {
  let mut success = 0;
  glGetShaderiv(fragment_shader, GL_COMPILE_STATUS, &amp;mut success);
  if success == 0 {
    let mut v: Vec&lt;u8&gt; = Vec::with_capacity(1024);
    let mut log_len = 0_i32;
    glGetShaderInfoLog(
      fragment_shader,
      1024,
      &amp;mut log_len,
      v.as_mut_ptr().cast(),
    );
    v.set_len(log_len.try_into().unwrap());
    panic!(&quot;Fragment Compile Error: {}&quot;, String::from_utf8_lossy(&amp;v));
  }
}
<span class="boring">}</span></code></pre></pre>
<p>This is all a very good candidate for wrapping into an easier to use function,
but we'll get to that after we can at least see a triangle.</p>
<h3 id="create-a-program"><a class="header" href="#create-a-program">Create A Program</a></h3>
<p>A program combines several shader &quot;stages&quot; such as vertex and fragment, and lets you have a completed graphics pipeline.</p>
<p>We use <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateProgram.xhtml"><code>glCreateProgram</code></a> to create one, and then we use <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glAttachShader.xhtml"><code>glAttachShader</code></a> to connect both shaders we have so far. Finally we call <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glLinkProgram.xhtml"><code>glLinkProgram</code></a> to connect the shader stages into a single, usable whole.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe {
  let shader_program = glCreateProgram();
  glAttachShader(shader_program, vertex_shader);
  glAttachShader(shader_program, fragment_shader);
  glLinkProgram(shader_program);
}
<span class="boring">}</span></code></pre></pre>
<p>And we have to check the <code>GL_LINK_STATUS</code> with <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgram.xhtml"><code>glGetProgramiv</code></a>, and grab the link error log if there was a link error.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe {
  let mut success = 0;
  glGetProgramiv(shader_program, GL_LINK_STATUS, &amp;mut success);
  if success == 0 {
    let mut v: Vec&lt;u8&gt; = Vec::with_capacity(1024);
    let mut log_len = 0_i32;
    glGetProgramInfoLog(
      shader_program,
      1024,
      &amp;mut log_len,
      v.as_mut_ptr().cast(),
    );
    v.set_len(log_len.try_into().unwrap());
    panic!(&quot;Program Link Error: {}&quot;, String::from_utf8_lossy(&amp;v));
  }
}
<span class="boring">}</span></code></pre></pre>
<p>Finally, and this part <em>is</em> a little weird, we can mark the shaders to be deleted with <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteShader.xhtml"><code>glDeleteShader</code></a>. They won't <em>actually</em> get deleted until they're unattached from the program we have, but we can call delete now and worry about one less thing later on.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe {
  glDeleteShader(vertex_shader);
  glDeleteShader(fragment_shader);
}
<span class="boring">}</span></code></pre></pre>
<p>Finally, after all that, we can call
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUseProgram.xhtml"><code>glUseProgram</code></a>
to set our program as the one to use during drawing.</p>
<h2 id="vsync"><a class="header" href="#vsync">Vsync</a></h2>
<p>Last thing before we move on to the main loop, let's turn on
<a href="https://en.wikipedia.org/wiki/Screen_tearing#Vertical_synchronization">vsync</a>,
which will make our <code>swap_window</code> call block the program until the image has
actually been presented to the user. This makes the whole program run no faster
than the screen's refresh rate, usually at least 60fps (sometimes more these
days). This is usually a good thing. We can't show them images faster than the
screen will present them anyway, so we can let the CPU cool down a bit, maybe
save the battery even if they're on a laptop.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// this goes any time after window creation.
win.set_swap_interval(SwapInterval::Vsync);
<span class="boring">}</span></code></pre></pre>
<h2 id="clear-the-screen"><a class="header" href="#clear-the-screen">Clear The Screen</a></h2>
<p>In the main loop, after we process our events, we start our drawing with a call
to
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClear.xhtml"><code>glClear</code></a>.
In this case we specify the <code>GL_COLOR_BUFFER_BIT</code>, since we want to clear the
color values. You could clear the other bits too, but since we're not using them right now we'll just clear the colors.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe {
  glClear(GL_COLOR_BUFFER_BIT);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="draw-the-triangle"><a class="header" href="#draw-the-triangle">Draw The Triangle</a></h2>
<p>To actually draw our triangle we call <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawArrays.xhtml"><code>glDrawArrays</code></a>.</p>
<ul>
<li>The <code>mode</code> is how to connect the vertexes together. We use <code>GL_TRIANGLES</code>
which makes it process the vertexes in batches of 3 units each into however
many triangles that gets you.</li>
<li>The <code>first</code> value is the first vertex index to use within our vertex buffer
data. Since we want to draw all three of our vertexes, we start at index 0.</li>
<li>The <code>count</code> value it the number of indices to be drawn. Since we want to draw
all three of our vertexes, we use 3.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe {
  glDrawArrays(GL_TRIANGLES, 0, 3);
}
<span class="boring">}</span></code></pre></pre>
<p>Be <em>extra careful</em> with this call. If you tell it to draw too many triangles the
GPU will run right off the end of the array and segfault the program.</p>
<h2 id="swap-the-window-buffers"><a class="header" href="#swap-the-window-buffers">Swap The Window Buffers</a></h2>
<p>Once the drawing is done, we have to swap the window's draw buffer and display
buffer, with <code>swap_window</code>. This will make the picture we just drew actually be
displayed to the user. With vsync on it'll also block until the image is actually displayed.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>win.swap_window();
<span class="boring">}</span></code></pre></pre>
<h2 id="done"><a class="header" href="#done">Done!</a></h2>
<ul>
<li>Example Code: <a href="https://github.com/rust-tutorials/learn-opengl/blob/master/examples/001-triangle-arrays1.rs">001-triangle-arrays1</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../basics/000-creating-a-window.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../basics/002-triangle-cleanup.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../basics/000-creating-a-window.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../basics/002-triangle-cleanup.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
